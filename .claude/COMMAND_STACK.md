# Command Stack - コマンドスタック手法

**Version**: 1.0.0
**Last Updated**: 2025-11-07
**Concept**: 階層的タスク分解と連鎖実行

---

## 🎯 概要

**Command Stack（コマンドスタック）**は、複雑なタスクを構造化された見出しとユーザープロンプトのペアに分解し、連鎖的に実行することで最終成果物を生成する手法。

### 核心原則

```
複雑なタスク → [C1] 構造化 → [C2] プロンプト化 → [C3] 連鎖実行 → 最終成果物
```

---

## 📋 基本構文

### テンプレート

```
＝＝＝
ゴールは：{{最終的に達成したい目標}}
成果物は：{{生成すべき具体的なアウトプット}}
参考例は：{{参考にすべき例やフォーマット}}
＝＝＝

[C1]: 見出しを構造化して整理します
      インデックスとして行動化してインデント構造で構造化し
      見出しの内容を上位構造、中位構造、下位構造で構造化します

[C2]: 見出しに対して、各見出しに対してのインストラクションとして
      ユーザープロンプトを作ってください。
      必ずUserの求める成果物を生成するための指示です。
      キーのペアの要素として見出しの構造と見出しに対する
      差し込みのユーザーインプットとしてのユーザープロンプトを作ります。

[C3]: 各見出しとユーザープロンプトのペアを実行していきます
      それぞれインデックスとして1番からN番まで番号を振って
      コマンドラン1からnとして連続でループします
      1からnとして連続でループして最終成果物を書き出す

'''
[成果物 XXを書く]

C1 C2 C3 All Run
'''

Task1[]
Task2[]
Task3[]
```

---

## 🔄 3ステップワークフロー

### [C1] 構造化フェーズ

**目的**: タスクを階層構造に分解

**プロセス**:
1. 最終成果物から逆算して必要な見出しを抽出
2. 上位構造（章レベル）、中位構造（節レベル）、下位構造（項目レベル）に階層化
3. インデント構造で視覚的に整理
4. 各見出しにインデックス番号を付与

**出力例**:
```
1. 上位構造: プロジェクト概要
   1.1 中位構造: 目的と背景
       1.1.1 下位構造: ビジネス目標
       1.1.2 下位構造: 技術的課題
   1.2 中位構造: スコープ定義
       1.2.1 下位構造: 対象範囲
       1.2.2 下位構造: 除外項目

2. 上位構造: 技術設計
   2.1 中位構造: アーキテクチャ
   2.2 中位構造: データモデル
   ...
```

---

### [C2] プロンプト化フェーズ

**目的**: 各見出しに対応する実行可能なユーザープロンプトを作成

**プロセス**:
1. C1で作成した各見出しに対して、具体的な指示文を作成
2. 見出し（Key）とプロンプト（Value）のペアを形成
3. プロンプトは成果物生成のための明確な指示を含む
4. 前のステップの出力を次のステップの入力として利用可能にする

**出力例**:
```
見出しペア:
{
  "1.1.1 ビジネス目標": {
    "prompt": "このプロジェクトが解決すべきビジネス課題を3つ挙げ、それぞれに対する定量的な成功指標を定義してください。"
  },
  "1.1.2 技術的課題": {
    "prompt": "ビジネス目標を達成するために克服すべき技術的な障壁をリストアップし、各課題に対する解決アプローチを提案してください。"
  },
  "2.1 アーキテクチャ": {
    "prompt": "前のステップで特定した技術的課題を考慮し、システムアーキテクチャ図を作成してください。主要コンポーネントと通信フローを含めること。"
  }
}
```

---

### [C3] 連鎖実行フェーズ

**目的**: プロンプトを順次実行し、最終成果物を生成

**プロセス**:
1. インデックス1からN番まで順番にプロンプトを実行
2. 各ステップの出力を次のステップのコンテキストとして渡す
3. 累積的に成果物を構築
4. 全ステップ完了後、統合された最終成果物を出力

**実行例**:
```
CommandRun 1: [1.1.1 ビジネス目標を実行]
  Output: "課題1: 顧客獲得コスト削減（目標: 30%削減）..."

CommandRun 2: [1.1.2 技術的課題を実行]
  Input: CommandRun 1の出力
  Output: "障壁1: レガシーシステムとの統合..."

CommandRun 3: [2.1 アーキテクチャを実行]
  Input: CommandRun 1-2の出力
  Output: "[アーキテクチャ図] + [設計説明]..."

...

CommandRun N: [最終統合]
  Input: CommandRun 1-(N-1)の全出力
  Output: [完成した成果物]
```

---

## 🎯 実践例

### 例1: API設計ドキュメント作成

```
＝＝＝
ゴールは：RESTful API設計ドキュメントの完成
成果物は：OpenAPI 3.0準拠のAPI仕様書（YAML）
参考例は：Stripe API、GitHub API
＝＝＝

[C1] 構造化:
1. API概要
   1.1 認証方式
   1.2 レート制限
2. エンドポイント定義
   2.1 ユーザー管理
       2.1.1 GET /users
       2.1.2 POST /users
   2.2 認証
       2.2.1 POST /auth/login
3. データモデル
   3.1 Userスキーマ
   3.2 Tokenスキーマ
4. エラーハンドリング

[C2] プロンプト化:
{
  "1.1 認証方式": "API認証にOAuth 2.0とAPIキーの2方式を実装。各方式のフローと使用例を記述",
  "2.1.1 GET /users": "ユーザー一覧取得エンドポイント。クエリパラメータ、レスポンス形式、エラーコードを定義",
  "3.1 Userスキーマ": "User objectの全フィールド定義。型、必須/任意、バリデーションルールを含む",
  ...
}

[C3] 連鎖実行:
CommandRun 1-N → 各プロンプトを実行 → 統合 → api-spec.yaml出力
```

---

### 例2: World Model Logic ドキュメント作成（実際の使用例）

```
＝＝＝
ゴールは：World Model Logicの体系的なドキュメント化
成果物は：WORLD_MODEL_LOGIC.md（8KB+の詳細ドキュメント）
参考例は：量子力学、状態機械、関数型プログラミング
＝＝＝

[C1] 構造化:
1. 概念定義
   1.1 World Model Logicとは
   1.2 4つの核心概念
2. 瞬く景色（Flickering Scenery）
   2.1 定義
   2.2 メタファー
   2.3 特性
3. World State
   3.1 数学的表現
   3.2 プロパティ
4. World Transition Logic
   4.1 6つの変換フェーズ
   4.2 遷移の性質
5. World Perception
   5.1 認識の階層
6. 動作サイクル
7. 実装
   7.1 Orchestratorとの関係
   7.2 Rustコード例
8. 哲学的考察

[C2] プロンプト化:
{
  "1.1 World Model Logicとは": "エージェントが認識・操作する世界の状態とその遷移論理を定義する概念フレームワークを説明",
  "2.1 定義": "『瞬く景色』の概念 - 世界を離散的な景色として瞬間的に捉える仕組みを詳述",
  "4.1 6つの変換フェーズ": "θ₁〜θ₆の各フェーズを数式と図解で説明",
  ...
}

[C3] 連鎖実行:
CommandRun 1-8 → 各セクションを生成 → 統合 → WORLD_MODEL_LOGIC.md出力
```

---

## 🧩 World Model Logicとの統合

Command Stackは、World Model Logicにおける**θ₂ Generate（計画生成）**フェーズの具体的実装手法。

### 関係性

```
θ₁ Understand: タスクを理解
   ↓
θ₂ Generate: Command Stack適用
   ├─ [C1] 構造化 → タスク分解
   ├─ [C2] プロンプト化 → 実行計画
   └─ [C3] 連鎖実行 → 実行シーケンス生成
   ↓
θ₃ Allocate: リソース割り当て
   ↓
θ₄ Execute: 各コマンド実行（World₀ → World₁ → ... → World_N）
   ↓
θ₅ Integrate: 結果統合
   ↓
θ₆ Learn: 学習・最適化
```

### Command Stackによる「瞬く景色」の生成

```
World₀ (初期状態)
   ↓
[CommandRun 1] → World₁ (見出し1完了)
   ↓
[CommandRun 2] → World₂ (見出し2完了)
   ↓
[CommandRun 3] → World₃ (見出し3完了)
   ↓
...
   ↓
[CommandRun N] → World_N (最終成果物完成)
```

各CommandRunが1つの「瞬き」に対応し、世界状態を段階的に変換していく。

---

## 🛠️ Claude Code/Codexでの使用方法

### 手動実行

```bash
# ユーザーがCommand Stackテンプレートを入力
User: """
＝＝＝
ゴールは：Rust製CLIツールの設計
成果物は：設計ドキュメント + コード骨格
参考例は：ripgrep, fd
＝＝＋

[C1] [C2] [C3]の定義...
"""

# Claude/Codexが3フェーズを実行
Agent:
  Step 1: 構造化実行...
  Step 2: プロンプト化実行...
  Step 3: 連鎖実行...
  → 最終成果物出力
```

### 自動化（Slash Command）

`.claude/commands/`に配置：

```bash
# /command-stack コマンドを定義
/command-stack goal="API設計" output="api-spec.yaml" reference="Stripe API"
```

---

## 📊 メリット

### 1. **構造化思考**
- 複雑なタスクを階層的に分解
- 全体像の把握が容易

### 2. **再現性**
- 同じCommand Stackを使えば同じ成果物が生成可能
- バージョン管理可能

### 3. **段階的実行**
- 各ステップの検証が可能
- エラー発生時の特定が容易

### 4. **並列化の可能性**
- 依存関係のないコマンドは並列実行可能
- Orchestrator-Subagent Architectureと相性が良い

### 5. **学習効率**
- 成功したCommand Stackをテンプレート化
- θ₆ Learnフェーズで最適化

---

## 🎓 ベストプラクティス

### 1. 適切な粒度

**Good**:
```
2.1 データモデル設計
   2.1.1 Userエンティティ
   2.1.2 Postエンティティ
```

**Bad** (粒度が粗すぎ):
```
2. システム設計
```

### 2. 明確なプロンプト

**Good**:
```
"Userエンティティの全フィールドを定義。各フィールドの型、バリデーションルール、デフォルト値を含む。"
```

**Bad** (曖昧):
```
"Userを定義して"
```

### 3. 依存関係の明示

```
{
  "3.1 実装": {
    "prompt": "2.1のデータモデルに基づいて、CRUDロジックを実装",
    "depends_on": ["2.1"]
  }
}
```

### 4. チェックポイントの設定

```
CommandRun 5完了後: 中間レビュー
CommandRun 10完了後: 統合テスト
CommandRun N完了後: 最終検証
```

---

## 🔗 関連概念

| 概念 | 関係性 |
|------|--------|
| World Model Logic | Command Stackは θ₂ Generateの具体的実装 |
| Orchestrator-Subagent | 各CommandRunをSubagentに委譲可能 |
| Agent Society | 複数Agentで並列にCommandRun実行 |
| MCP Integration | 外部ツールをCommandRunに統合 |

---

## 📚 参考

- `WORLD_MODEL_LOGIC.md` - 理論的基盤
- `AGENT_SOCIETY.md` - 並列実行との統合
- `../README.md` - プロジェクト全体像

---

**Note**: このCommand Stack手法は、Shunsuke Hayashiによって開発されたタスク分解・実行メソッドです。
